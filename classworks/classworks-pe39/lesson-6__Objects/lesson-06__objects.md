# Объекты
Комплексный тип данных, который позволяет хранить в себе любое количество любых других типов данных. Проще говоря - еще один важный строительный блок.

Данные внутри объекта хранятся парами `ключ` - `значение`.

#### Синтаксис:
```js
const user = {
  name: "Eran",
  age: 40
}
```
В данном случае `name` и `age` - свойства объекта, они же - ключи, по которым хранится информация об имени и возрасте соответственно.

#### Ссылочный тип данных
Это значит, что в переменную записывается не сам объект, со всеми потрохами в виде свойств и их значений. Нет, в переменную попадает только ссылка на ячейку в памяти, где объект находится.

Похоже на адрес прописки в паспорте. В разных инстанциях мы указываем один и тот же адрес, по которому нас можно найти. Похожим образом и работает присвоение ссылки на объект в переменную.

```js
let info = {
  headline: "Selections reesults comming out",
  text: "Lorem ipsum dolor sit amet concestetur...."
} // создаем объект. в переменную записывается ссылка на него

let infoCopy = info; // в новую переменную записывается все та же ссылка на тот же объект

infoCopy.headline = "No any headline"; // изменится свойство объекта, ссыка на который записана в двух переменных

console.log(info.headline); // в консоль попадет "No any headline", так как обращались мы по тому же адресу в памяти, что и раньше, а значит и изменили все тот же объект
```

#### Как получить значение свойства?
Есть три способа это сделать:
1) `user.name` - когда мы точно знаем имя свойства/ключа
2) `user["birth date"]` - когда имя ключа по какой-то причине не соответствует правилам синтаксиса языка
3) `user[propertyName]` - когда есть некая переменная, которая содержит имя свойства/ключа. В нашем случае такая переменная - `propertyName`, будем считать что она объявлена где-то выше.

#### Методы объекта
Метод - это свойство, значением которого является функция. Такие вложенные функции чаще всего нужны для того, чтобы как-то управлять данными, которые уже есть в объекте.

Допустим есть объект с данными пользователя:
```js
const user = {
  name: "Henry",
  age: 24,
  accessLevel: "junior"
}
```
и было бы хорошо иметь возможность изменять уровень доступа пользователя, потому что Henry получил повышение.
  
Для этого можно добавить объекту метод `changeAccessLevel(newValue)`, который в качестве аргумента будет принимать новое значение.

### Контекст выполнения - `this`
В случае с методами объекта все на самом деле просто. Потому как вызванный метод объекта `user` будет выполняться в конексте этого самого объекта.

Если создать метод объекта и внутри попробовать вывести в консоль значение `this` - мы получим тот же объект к котрому и принадлежит метод.

```js
const user = {
  name: "Henry",
  age: 24,
  accessLevel: "junior",
  changeAccessLevel: function (newValue) {
    console.log(this) // в консоли окажется объект user
  }
}

user.changeAccessLevel("middle") //ничего не изменится, так как в методе написан только вывод в консоль
```

теперь мы без труда можем дописать одну строку кода и дать Henry возможность расширить свой уровень доступа.

```js
const user = {
  name: "Henry",
  age: 24,
  accessLevel: "junior",
  changeAccessLevel: function (newValue) {
    this.accessLevel = newValue
  }
}

user.changeAccessLevel("middle") // значение свойства accessLevel у объекта будет заменено не то, которое передано в качестве аргумента
```



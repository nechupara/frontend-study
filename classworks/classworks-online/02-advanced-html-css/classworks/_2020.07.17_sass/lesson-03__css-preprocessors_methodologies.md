# CSS препроцессоры, CSS методологии

## Методология БЕМ
Название методологии - это аббревиатура от `Блок Элемент Модификатор`. Предполагает, что вся разработка будет сводитсья к созданию независимых блоков, которые могут друг с другом взаимодействовать определенным образом.

#### Блок
Это независимый компонент страницы, который может быть повторно использован в другом месте страницы

#### Правила именования блоков:
* Название блока отвечает на вопрос "Что это?" (кнопка - btn, заголовок секции - section-title), а не "Как это выглядит?" (btn-green, color-red);

* Название блока должно быть говорящим и четко указывающим на то, какой смысловой независимый элемент на странице этот класс определяет: кнопка, заголовок, форма, меню и т.д.

* Название блока может содержать несколько слов, которые пишутся через дефис (section-title, search-form и т.д.)

* У элемента не может быть двух классов-блоков.

#### Правила написания CSS для блока:
* Внешний вид блока определяется только его классами, а значит - никакого наследования CSS свойств от родителей и никаких вложенных селекторов (.section-parallax .btn - неправильно);
  
* Блок не должен влиять на свое окружение, т.е. блоку не следует задавать внешнюю геометрию (в виде margin) и позиционирование (position). Если их все-таки нужно указать для правильного размещения конкретного элемента на странице, то вам нужно вынести эти свойства в отдельный класс, так называемый микс (детальнее будет рассмотрено ниже).

#### Элемент
Это составная часть блока, которая не может использоваться в отрыве от него. То есть, смотря на макет, невозможно представить, что этот дизайнерский элемент может находиться где-то в другом месте на странице, не будучи вложенным в родительский блок. Пример - пункт меню. Очевидно, что он не может существовать сам по себе, вне самого меню.

#### Правила именования элементов:
* Структура полного имени элемента соответствует схеме: имя-блока__имя-элемента. имя-блока - название класса для блока, внутри которого находится элемент. Потом идут два нижних подчеркивания и имя элемента. То есть заголовок в шапке сайта (.header) будет иметь класс header__title. Слоган в шапке сайта - соответственно header__slogan.

* Имя элемента может состоять из несколько слов, написанных через дефис. Например, внутри блока "Новости" (.news) у вас есть элементы "краткий текст новости" и "полный текст новости". Полное название классов для этих элементов будет: news__short-text и news__full-text.

* Название элемента отвечает на вопрос "Что это?", а не "Как это выглядит?".

* Элемент - всегда часть блока, а не другого элемента. Это означает, что в названии элементов нельзя указывать имя другого элемента, даже если элемент в него вложен. Представим картину: у вас есть ссылки внутри элемента news__full-text. И мы хотим присвоить им класс. НЕправильно: news__full-text__link. Правильно: news__text-link.

* Элемент не может быть одновременно и блоком.

* Структура элементов внутри блока:

* Не у всех блоков могут или должны быть элементы (например кнопка – это всегда блок, но внутри у нее обычно просто текст).

* Блок может повторно использоваться только с частью входящих в него элементов. Например, у вас на странице есть блок с новостями, внутри которого блоки - это отдельные новости. И блок отдельной новости (.news) может содержать такие элементы: news__title, news_img, news__date, news__more, news__description. А в другом месте страницы у вас есть блок с кратким текстовым перечнем новостей, где вам не нужны картинки новости, краткое описание и ссылка на Read more, а только дата и заголовок новости. А значит это будет блок news, внутри которого будут только такие элементы: news__title и news__date.

* Элементы можно вкладывать друг в друга.

* Допустима любая вложенность элементов.

#### Модификатор 
Это сущность, определяющая внешний вид, состояние или поведение блока либо элемента. По сути, в модификатор вы выносите ту часть CSS свойств блока/элемента, которые могут меняться в зависимости от уточненной роли этого компонента.

#### Правила использования модификаторов:
* Модификатор нельзя использовать самостоятельно, только в дополнение к классу блока или элемента (вторым/третьим и т.д. классом у тега).

* Количество модификаторов у одной сущности не ограничено. Пример: у нас есть базовый класс .btn, который определяет семейство шрифта для текста внутри кнопки, толщину рамки, значение свойства display и закругление краев. Это одинаковые свойства для всех кнопок. А различаются они размерами (CSS свойства font-size и padding), и цветом текста (CSS свойство color). Значит, мы добавляем тегу а помимо класса .btn еще два - модификатор размера и цвета текста. 

#### Правила именования модификаторов:
* Имя модификатора отделяется от имени блока или элемента двумя тире (--): btn--small, menu-top__link--selected. То есть полное имя модификатора блока будет выглядеть так: имя-блока--имя-модификатора. Полное имя модификатора элемента будет выглядеть так: имя-блока__имя-элемента--имя-модификатора. Также существует альтернативный вариант написания модификатора - через подчеркивание (_). В таком случае полное имя модификатора блока будет выглядеть так: имя-блока_имя-модификатора. Полное имя модификатора элемента будет выглядеть так: имя-блока__имя-элемента_имя-модификатора

* Название модификатора может характеризовать внешний вид: `size-s`, `theme-islands`, состояние: `disabled`, `focused`, и поведение: `directions-left-top`

* Модификаторы условно делятся на:
    * Булевые: `disabled`, `enabled`, `active`. В таком случае полное имя модификатора будет: `имя-блока__имя-элемента_имя--модификатора`
    
    * Ключ-значение: когда важно не только имя, но и значение. Например, модификатор размера - `size` и его значение - `m`. Полное имя модификатора будет: `имя-блока__имя-элемента--имя-модификатора-значение-модификатора`, т.е. кнопка формы с таким модификатьором будет иметь класс - `form__button--size-m`
    
## SASS, SCSS
Кода для стилей очень много, его хочется структурировать и оптимизировать процесс написания. Именно эту проблему для нас решают CSS препроцессоры.

SASS, SCSS имеют одни и те же фичи, но принципиально отличаются только наличием или отсуствием знаков препинания: фигурные скобки, точки с запятой и тд. В `SASS` - все регулируется табуляциями, а в `SCSS` - привычный CSS синтаксис.

#### Переменные
Объявления переменной похоже на присвоение свойства, только не привязанного ни к одному классу.

Чаще всего используют для того, чтобы один раз на весь проект указать палитру цветов и/или размеры экранов устройств, на которые нужно ориентировать верстку.
```scss
$primary: #3f3f3f
```

#### Mixin-ы
По синтаксису и назначению очень похожи на функцию в JavaScript. Нужны для того, чтобы сократить количество одинакового кода. 

К примеру, каждый раз для заголовков мы присваиваем один и тот же набор свойств - размер шрифта, его жирность и цвет. Все эти три свойства можно "запаковать" в миксин и пользоваться им в одну строку, просто указав все три значения как аргументы функции.

```scss
@mixin title($size, $weight, $color) {
  font-size: $size;
  font-weight: $weight;
  color: $color;
}

.section-title {
  @include title(24px, 600, #3f3f3f);
}
```

Миксины есть смысл определить в отдельном файле и подключить его перед всеми стилями в главный файл, чтобы во всех сложенных можно было пользоваться созданными сикращениями.

#### Функции

```scss
@use "sass:math";

//---------------------------------------------------------------------------------------
// PX TO EM conversion @include em(12px, basefontsize);
//---------------------------------------------------------------------------------------
@function to-em($px, $base) {
   @if $px == 0 { @return 0 }
   //@return $px / $base + 0em; deprecated and will be removed in Dart Sass 2
   @return math.div($px, $base) + 0em;
}

@function em($px, $base) {
   @return to-em($px, $base);
}
```

#### Вложенность классов
При именовании классов, тем более по БЕМ-у, возникает ощутимая проблема - названия классов частично или полностью повторяют друг друга. В препроцессорах это решается очень просто, мы используем вложенность.

К примеру, такой CSS код:
```css
.box {
  display: flex;
  align-items: center;
}

.box__link {
  font-size: 24px;
  font-weight: 700;
  text-decoration: none;
  color: #3f3f3f;
}

.box__link--bg-grey {
  border-radius: 50%;
  background-color: grey;
}

.box__link:hover {
  color: #5e5e5e;
}
```

Может быть с легкостью переписан следующим образом:
```scss
.box {
  display: flex;
  align-items: center;

  &__link {
  font-size: 24px;
  font-weight: 700;
  text-decoration: none;
  color: #3f3f3f;

    &--bg-grey {
      border-radius: 50%;
      background-color: grey;
    }
    
    &:hover {
      color: #5e5e5e;
    }
  }
}
```

Каждый раз, когда мы пишем `&` мы грубо говоря дописываем нужную часть к селектору, который был выше в коде.

Если следовать принципам именования классов из методологии БЕМ, то такая фича препроцессора SCSS сильно сокращает время написания селекторов. Более того, итоговый код становится проще читать.



Минус такого подхода **<u>&__link</u>** что вы не сможете сделать поиск по проекту так как в браузере вы видите полный селектор **.box__link** по этому **МОЯ РЕКОМЕНДАЦИЯ** не когда не использовать частичный селектор **&__link** а всегда использовать полный 

```scss
.box {
  display: flex;
  align-items: center;

  .box__link {
  font-size: 24px;
  font-weight: 700;
  text-decoration: none;
  color: #3f3f3f;

    .box--bg-grey {
      border-radius: 50%;
      background-color: grey;
    }
    
    &:hover {
      color: #5e5e5e;
    }
  }
}
```
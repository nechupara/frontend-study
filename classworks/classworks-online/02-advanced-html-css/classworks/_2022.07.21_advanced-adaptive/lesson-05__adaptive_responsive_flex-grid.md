# Adaptive, responsive, using flex and grid

Подойи к реализации адапивной и/или резиновой верстки можно с нескольких сторон, используя разные подходы и технологии. По этому мы рассмотрим использование FlexBox и Grid Layout как самый ярких представителей.

Тут будут описаны основные моменты, для которых часто используется каждая технология.

## Flexbox
При создании верхнего навигационного меню на сайте нужно подготовить себя к тому, что на каком-то разрешении нужно будет сделать его вертикальным и убрать/переместить часть элементов.

Иногда для этого создают дубликат меню, с нужным содержимым и другими классами. В более легких случаях, можно обойтись медиазапросами с заменой нескольких свойств.

Так как в мобильном варианте пункты меню будут расположены друг под другом, то можно изначаль но заключить их в flex container:
```scss
.top-nav {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
```
Для того, чтобы на разрешении 768px меню изменило порядок отображения пунктов:
```scss
@media (max-width: 768px) {
    .top-nav {
      flex-direction: column;
    }
}
```

### Колокни
Для создания любого количества колонок можно использовать прием:
```scss
.columns {
  display: flex;
  align-items: center;
  
  &__item {
    width: calc(100% / 3); // где вместо 3 может стоять любое нужное число
  }
}
``` 
Нужно изменить количество колонок на каком-то из разрешений? Внутри медиазапроса меняем ширину и все будет ок. Происходит это за счет того, что значение `justify-content` по умолчанию равно `stretch`, а это значит, что все дочерние элементы будут занимать 100% ширины родительского и равномерно уменьшатся, если вдруг места не хватит.

Вместо `width` можно использовать `flex-basis`. Отличается это свойство тем, что при смене `flex-direction` оно станет отвечать за высоту.

Помните так же, что при смене `flex-direction` изменяется и направленя в которых работают `align-items` и `justify-content`.

Чтобы не заморачиваться с размещением всех элементов строго в нужной колонке, можно просто добавить родительскому элементу `flex-wrap` и теперь дочерние элементы, которым не хватает места будут "перепрыгивать" на следующую строку.

## Grid Layout
В комбинации с медиазапросами обычные свойства `grid-template-columns` и `grid-gap` уже способны для нас делать разную разметку страницы для разных разрешений.

Прелесть в том, что глобальное размещение основных блоков мы можем менять в 1-2 строках одного класса в медиазапросе.

По этому создав нужное количество колонок и строк, можно оперировать положением основных блоков внутри, при помощи свойств: `grid-column`, `grid-row` и `grid-area`.

* **`grid-column`** - есть несколько способов задать значение этому свойству. Самый простой - два числа, которые будут указывать на номер колонки с которой нужно начать и номер колонки, до начала которой нужно чтобы элемент растянулся. Но есть и более продвинутый вариант записи с ключевым словом `span`. Нужно указать только номер колонки, с которой элемент должен начинаться, заем написать слово `span` и после него указать сколько колонок элемент должен занимать, таким образом:
    ```css
   .page-sidebar {
      grid-column: 1 / 3; /* этот элемент займет 2 колонки, с начала первой до начала третьей */
   }
   .page-content {
      grid-column: 2 / span 3; /* этот элемент займет три колонки, начиная с колонки номер 2 */
   }
    ```

* **`grid-row`** - задается таким же способом, как и `grid-column`, но отвечает за рядки/столбцы, т.е. вертикальную ось.

* **`grid-area`** - является сокращением от двух предыдущих. Принимает 4 числа, разделенных при помощи `/` в таком порядке:
  `grid-column-start`,
  `grid-column-end`,
  `grid-row-start`,
  `grid-row-end`.

  Есть еще один, менее удобный, вариант значения - слово с названием зоны из свойства `grid-template-areas` у родительского элемента.  
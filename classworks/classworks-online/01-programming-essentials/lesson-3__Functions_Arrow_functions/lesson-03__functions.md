# Функции
Функции это основной "строительный блок", который позволяют написать код один раз и использовать его неограниченное количество раз в дальнейшем. 

Для того, чтобы в коде появилась функция - ее нужно объявить. После объявления ее можно будет вызвать сколько угодно раз.

Переменные, которые мы объявляем внутри функции будут доступны только внутри функции.

В то жу время функция обладает полным доступом к внешним переменным и может изменять их значение. Внешняя переменная используется, только если внутри функции нет такой локальной. Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.




### Объявление 
Для того, чтобы дать браузеру знать, что мы хотим объявить функцию используется ключевое слово `function`. После которого следует написать имя функции (его мы придумываем сами).

```js
/* объявление функции */
function showMessage () {
  alert("Hello world")
}

/* вызов функции */
showMessage() // выведет на экран модальное окно с сообщением "Hello world"
```

Было бы на много удобнее, если бы мы могли при вызове функции передать ей сообщение, которое хотим передать на этот раз. Для таких целей есть **аргументы** или **параметры** функции.

```js
/* объявление функции */
function showMessage (message) {
  alert(message)
}

/* вызовы функции */
showMessage("Hey! Let's play.") // выведет на экран модальное окно с сообщением "Hey! Let's play."
showMessage("My name is Chrome") // выведет на экран модальное окно с сообщением "My name is Chrome"
```

### Возвращаемое значение
Часто важно не просто вызвать функцию и выполнить какой-то код ,а еще и увидеть результат. Это может быть что угодно от числа до объекта со сложной структурой, но так или иначе - нам важно его получить после выполнения кода функции.

Для этого есть ключевое слово `return`, которое ожидает после себя что-то, что и будет возвращаемым значением функции. Это может быть что угодно - число, объект, массив, строка и тд.

По умолчанию каждая функция в JavaScript возвращает `undefined`.

```js
function sum (a,b) {
  return a + b; // возвращаемым значение функции будет результат суммирования двух аргументов
}

let sumNumbers = sum(10,6); //в переменную попадет число 16
```

Если при вызове какой-то из параметров не был передан - его значением будет `undefined`.

```js
let sumNumbers = sum(10);
```
в переменную попадет NaN, потому что второй параметр не был передан, а `10 + undefined` = `NaN`.

### Именование функций:

* Имя функции должно понятно и чётко отражать, что она делает. Увидев её вызов в коде, вы должны тут же понимать, что она делает, и что возвращает.
* Функция – это действие, поэтому её имя обычно является глаголом.
* Есть много общепринятых префиксов, таких как: create..., show..., get..., check... и т.д. Пользуйтесь ими как подсказками, поясняющими, что делает функция.

Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл разбить функцию на несколько меньших. Иногда следовать этому правилу непросто, но это определённо хорошее правило.

Небольшие функции не только облегчают тестирование, и отладку – само существование таких функций выполняет роль хороших комментариев!

# Стрелочные функции
Самое очевидное их отличие от обычных функций - синтаксис. Более короткая форма записи экономит наше время. Но это только верхушка айсберга.

#### Синтаксис
Есть несколько вариантов объявления стрелочной функции. От самого короткого, до многострочного.

**Самая короткая запись** - подходит для простых выражений, которые занимают одну строку.
```js
const sum = (a,b) => a + b;
```   
Все, что написано после `=>` стрелки - будет возвращаемым значением. Все равно что мы написали бы `return`.

Это же выражения, для большей ясности, можно обернуть в круглые скобки.
```js
const sum = (a,b) => (a + b);
```   

В случаях, когда функция принимает только один аргумент - его можно объявлять без скобок
```js
const isEven = number => number % 2 === 0;
```   

Многострочный синтаксис больше напоминает обычную функцию
```js
const myFunction = () => {
// ...
// код функции
// ...
}
```

#### Контекст выполнения
"Стрелки" не имеют своего собственного `this`. Она его **наследует** от родительской функции.

То есть `this` таки существует, всегда на что-то ссылается. Вопрос только в какой ситуации на что он будет указывать.

1) Если стрелочная функция объявлена в глобальном контексте, т.е. просто написана посреди файла - ее `this` ссылается на глобальный объект `Window`

2) Если стрелочная функция объявлена внутри обычной функции - `this` стрелочной будет ссылаться туда, куда ссылается и `this` обычной. Проще говоря, если `function` объявлена как метод объекта, то и у стрелочной контекстом будет этот объект.
    ```js
    const pizza = {
       name: "Margaritga",
       addExtras: function (extras) {
         console.log('context of function', this)
         const checkThis = () => console.log('context of arrow function', this)
       } 
    }
    ```
   Оба вывода в консоль вернут один и то же объект `pizza`


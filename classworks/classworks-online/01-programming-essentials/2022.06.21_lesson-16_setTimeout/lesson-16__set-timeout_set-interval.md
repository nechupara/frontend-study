# setInterval, setTimeout, localStorage, sessionStorage

## Планирование
Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».

Для этого существуют два метода:

* `setTimeout()` позволяет вызвать функцию один раз через определённый интервал времени.
* `setInterval()` позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

#### setTimeout
Выполнит переданную ему функцию через заданный промежуток времени. Применяется в анимации и для того, чтобы отсрочить какое-то событие.

**_Возвращаемое значение_** -  цифра, которая будет являться идентификатором этого конкретного timeout-a. 

**_Аргументы_:**
1) функция, вызов которой нужно отсрочить
2) количество миллисекунд, на которое нужно отсрочить запуск
3) Далее можно через запятую перечислить сколько угодно аргументов - все они будут переданы функции с отсрочкой 

**_Синтаксис:_** 
```js
const logHi = () => console.log('hi');   

setTimeout(logHi, 3000); //отсрочит вызов функции logHi на 3 секунды

const logMessage = message => console.log(message);

setTimeout(logMessage, 5000, "Hi from settimeout's arguments");
```
Во втором случае вызов функции logMessage будет отсрочен на 5000 и в качестве аргумента этой функции будет передано сообщение, которое указано 3-м аргументом у `setTimeout`.

Если вдруг случилось так, что нужно прервать timeout, можно вызвать функцию `clearTimeout`. В качестве аргумента ей нужно передать идентификатор timeout-a, который нужно прекратить.

#### setInterval
В большей степени, работает так же как и `setTimeout()` с одним только отличием - `setInterval` будет вызывать функцию с заданной отсрочкой до тех пор, пока мы не закроем интервал.

`setInterval` тоже возвращает идентификатор интервала, по этому закрытие будет выглядеть практически так же. 

## localStorage, sessionStorage
Есть ключевой момент разницы, который нужно запомнить. Это в целом следует из названий, но все же:
* `sessionStorage` - будет очищен как только пользователь покинет сайт
* `localStorage` - после того, как пользователь покинет сайт, продолжит свое существование

В остальном функционал этих локальных хранилищ одинаков. Размер хранилища - около 5 мегабайт. 

Таким образом получается что между сессиями или вовремя сессии у нас есть возможность хранить часть информации в операционной памяти пользовательского компьютера.

Данные хранятся в формате `ключ: значение` - очень похоже на то как мы их храним в обычных объектах. Как ключом, так и значением, может быть **только строка**.

**Методы:**
* `key(number)` - принимает число. Вернет имя ключа под этим номером 
* `getItem(key)` - принимает имя ключа, возвращает значние, которое под этим ключом записано
* `setItem(key, value)` - принимает имя ключа и значение, которое нужно с ним ассоциировать в хранилище
* `removeItem(key)` - принимает имя ключа и удаляет его вместе со значением
* `clear()` - полностью очищает все хранилище

#### Как записать объекты в localStorage?
Для записи в localStorage нужно преобразовать объект в строку так, чтобы можно было легко выполнить обратный процесс. Для этого у нас есть `JSON` - JavaScript Object Notation - текстовый формат представления JS объектов.

Для быстрой и удобной работы у нас есть одноименный объект `JSON` в распоряжении. Его методы способны выполнить и преобразование в строку, и ее считывание с последующим превращением в объект.

Все, что нужно это:
* `JSON.stringify({name: "Gogen""})` - и в результате мы получим строку в формате JSON
* `JSON.parse('{"name": "Gogen"}')` - и мы получим готовый к работе JS объект

В качестве аргумента, разумеется, можно передавать и переменные которые содержат данные для преобразования.  